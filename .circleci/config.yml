version: 2.1
setup: true

orbs:
  go: circleci/go@1.6.0
  continuation: circleci/continuation@0.1.0

jobs:
  verify-ci-should-run:
    docker:
      - image: circleci/golang:latest
    steps:
      - checkout
      - run:
          name: Verify CI should run
          command: |
            # run CI when manually triggers via CircleCi Dashboard
            # [ <<pipeline.trigger_source>> ~= 'api' ] && SHOULD_RUN_PIPELINES=1
  
            if [ -v "${CIRCLE_PULL_REQUEST##*/}" ]; then
              # Since we're piggybacking off of an existing OAuth var, tweak the var for our uses
              token=$(printf "${GITHUB_TOKEN}" | cut -d':' -f1)

              headers="Authorization: token $token"
              api_endpoint="https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/pulls/${CIRCLE_PULL_REQUEST##*/}"

              # Fetch PR metadata from Github's API and parse fields from json
              github_res=$(curl --silent --header "${headers}" "${api_endpoint}" | jq '{draft: .draft}')
              draft=$(printf "${github_res}" | jq '.draft')

              if [[ "${draft}" == true ]]; then
                printf "PR is a draft, skipping CI!\n"
                RUN_PIPELINES=0
              else 
                printf "Always run CI for PR that are ready for review!\n"
              fi
            else
              # only run CI when commit message includes 'run ci'
              LAST_LOG=$(git log -1 --grep="run ci" --pretty=%B)
              [ -z "$LAST_LOG" ] && RUN_PIPELINES=0
              
              if [[ "$CIRCLE_BRANCH" == "develop" || "$CIRCLE_BRANCH" == "release/"* ]]; then
                printf "Always run CI for develop and for release candidate branches.\n"

                RUN_PIPELINES=1
              fi
            fi
            
            echo "should run? $RUN_PIPELINES"
            if [[ "$RUN_PIPELINES" -eq "0" ]]; then
              printf "Don't run CI workflows\n"
              curl --request POST \
                --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel \
                --header "Circle-Token: ${CIRCLE_TOKEN}"
              sleep 30  # Give cancellation a chance to run. This script then won't continue running.
              exit 1  # If cancellation didn't run for some reason, fail the build.
            fi
  fluff:
    docker:
      - image: circleci/golang:latest
    steps:
      - run: echo 'Next Step'

      # - run:
      #   name: Dynamically generate the appropriate pipeline configuration
      #   command: |
      #     cd .circleci
      #     ls -la
      #     echo "Merge all YAML files into a dynamically generated pipeline.yml file"
      #     cat executors.yml commands.yml jobs.yml workflows.yml > pipeline.yml
      #     ls -a
      #     cat pipeline.yml
      # - continuation/continue:
      #   configuration_path: .circleci/pipeline.yml
      # - store_artifacts:
      #   path: .circleci/pipeline.yml
      #   destination yaml/pipeline.yml

workflows:
  # the always-run workflow is always triggered, regardless of the pipeline parameters.
  setup-workflow:
    jobs:
      - verify-ci-should-run:
          context: workflow-setup
      - fluff:
          requires:
            - verify-ci-should-run
    # jobs:
      # # the path-filtering/filter job determines which pipeline
      # # parameters to update.
      # - path-filtering/filter:
      #     name: check-updated-files
      #     mapping: |
      #       service1/.* run-build-service-1-job true
      #       service2/.* run-build-service-2-job true
      #     base-revision: main
      #     # this is the path of the configuration we should trigger once
      #     # path filtering and pipeline parameter value updates are
      #     # complete. In this case, we are using the parent dynamic
      #     # configuration itself.
      #     config-path: .circleci/continue_config.yml